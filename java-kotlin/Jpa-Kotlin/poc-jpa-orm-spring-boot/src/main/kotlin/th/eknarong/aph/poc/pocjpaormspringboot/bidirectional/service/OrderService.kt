package th.eknarong.aph.poc.pocjpaormspringboot.bidirectional.service

import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import th.eknarong.aph.poc.pocjpaormspringboot.bidirectional.entity.Order
import th.eknarong.aph.poc.pocjpaormspringboot.model.OrderStatus
import th.eknarong.aph.poc.pocjpaormspringboot.bidirectional.repository.OrderRepository
import th.eknarong.aph.poc.pocjpaormspringboot.bidirectional.repository.ProductRepository
import th.eknarong.aph.poc.pocjpaormspringboot.bidirectional.repository.UserRepository
import th.eknarong.aph.poc.pocjpaormspringboot.model.CreateOrderRequest
import th.eknarong.aph.poc.pocjpaormspringboot.model.OrderResponse
import th.eknarong.aph.poc.pocjpaormspringboot.model.UpdateOrderRequest
import th.eknarong.aph.poc.pocjpaormspringboot.model.UserSummary
import th.eknarong.aph.poc.pocjpaormspringboot.model.ProductSummary
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.*

// TODO : Check the correctness because the code below is generated by using AI.

@Service
@Transactional
class OrderService(
        private val orderRepository: OrderRepository,
        private val userRepository: UserRepository,
        private val productRepository: ProductRepository
) {
    
    fun createOrder(request: CreateOrderRequest): OrderResponse {
        val user = userRepository.findById(request.userId)
            .orElseThrow { IllegalArgumentException("User with id ${request.userId} not found") }
        
        val products = productRepository.findAllById(request.productIds)
        if (products.size != request.productIds.size) {
            val foundIds = products.map { it.id }
            val missingIds = request.productIds.filter { !foundIds.contains(it) }
            throw IllegalArgumentException("Products not found: $missingIds")
        }
        
        // Check stock availability
        products.forEach { product ->
            require ((product.stockQuantity?:0) > 0) { "Product '${product.name}' is out of stock" }
        }
        
        val orderNumber = generateOrderNumber()
        
        val order = Order(
            orderNumber = orderNumber,
            totalAmount = request.totalAmount,
            status = request.status,
            user = user,
            products = products,
            createdAt = LocalDateTime.now()
        )
        
        val savedOrder = orderRepository.save(order)
        
        // Update product stock
        products.forEach { product ->
            product.stockQuantity = product.stockQuantity!! - 1
            productRepository.save(product)
        }
        
        return mapToOrderResponse(savedOrder)
    }
    
    fun updateOrder(id: Long, request: UpdateOrderRequest): OrderResponse {
        val order = orderRepository.findByIdWithProducts(id)
            ?: throw IllegalArgumentException("Order with id $id not found")
        
        // Handle product updates
        val updatedProducts = request.productIds?.let { productIds ->
            val products = productRepository.findAllById(productIds)
            if (products.size != productIds.size) {
                val foundIds = products.map { it.id }
                val missingIds = productIds.filter { !foundIds.contains(it) }
                throw IllegalArgumentException("Products not found: $missingIds")
            }
            products
        } ?: order.products

        order.totalAmount = request.totalAmount ?: order.totalAmount
        order.status = request.status ?: order.status
        order.products = updatedProducts
        
        val savedOrder = orderRepository.save(order)
        return mapToOrderResponse(savedOrder)
    }
    
    fun updateOrderStatus(id: Long, status: OrderStatus): OrderResponse {
        val order = orderRepository.findByIdWithProducts(id)
            ?: throw IllegalArgumentException("Order with id $id not found")

        order.status = status
        val savedOrder = orderRepository.save(order)
        return mapToOrderResponse(savedOrder)
    }
    
    fun cancelOrder(id: Long): OrderResponse {
        val order = orderRepository.findByIdWithProducts(id)
            ?: throw IllegalArgumentException("Order with id $id not found")
        
        if (order.status == OrderStatus.DELIVERED) {
            throw IllegalArgumentException("Cannot cancel delivered order")
        }
        
        if (order.status == OrderStatus.CANCELLED) {
            throw IllegalArgumentException("Order is already cancelled")
        }
        
        // Restore product stock
        order.products?.forEach { product ->
            product.stockQuantity = product.stockQuantity!! + 1
            productRepository.save(product)
        }

        order.status = OrderStatus.CANCELLED
        val savedOrder = orderRepository.save(order)
        return mapToOrderResponse(savedOrder)
    }
    
    fun deleteOrder(id: Long) {
        val order = orderRepository.findById(id)
            .orElseThrow { IllegalArgumentException("Order with id $id not found") }
        
        orderRepository.delete(order)
    }
    
    fun getOrderById(id: Long): OrderResponse {
        val order = orderRepository.findByIdWithProducts(id)
            ?: throw IllegalArgumentException("Order with id $id not found")
        
        return mapToOrderResponse(order)
    }
    
    fun getAllOrders(): List<OrderResponse> {
        return orderRepository.findAll().map { order ->
            val orderWithProducts = orderRepository.findByIdWithProducts(order.id!!)!!
            mapToOrderResponse(orderWithProducts)
        }
    }
    
    fun getOrdersByUser(userId: Long): List<OrderResponse> {
        val orders = orderRepository.findByUserId(userId)
        return orders.map { order ->
            val orderWithProducts = orderRepository.findByIdWithProducts(order.id!!)!!
            mapToOrderResponse(orderWithProducts)
        }
    }
    
    fun addProductToOrder(orderId: Long, productId: Long): OrderResponse {
        val order = orderRepository.findByIdWithProducts(orderId)
            ?: throw IllegalArgumentException("Order with id $orderId not found")
        
        val product = productRepository.findById(productId)
            .orElseThrow { IllegalArgumentException("Product with id $productId not found") }
        
        if (order.products?.any { it.id == productId } == true) {
            throw IllegalArgumentException("Product is already in the order")
        }
        
        if (product.stockQuantity!! <= 0) {
            throw IllegalArgumentException("Product '${product.name}' is out of stock")
        }

        order.products = order.products?.plus(product)?.toMutableList() ?: mutableListOf(product)
        order.totalAmount = order.totalAmount?.add(product.price) ?: product.price
        
        val savedOrder = orderRepository.save(order)
        
        // Update product stock
        product.stockQuantity = product.stockQuantity!! - 1
        productRepository.save(product)
        
        return mapToOrderResponse(savedOrder)
    }
    
    fun removeProductFromOrder(orderId: Long, productId: Long): OrderResponse {
        val order = orderRepository.findByIdWithProducts(orderId)
            ?: throw IllegalArgumentException("Order with id $orderId not found")
        
        val product = order.products?.find { it.id == productId }
            ?: throw IllegalArgumentException("Product with id $productId not found in order")

        order.products = order.products?.filter { it.id != productId }?.toMutableList()
        order.totalAmount = order.totalAmount!! - product.price!!
        
        val savedOrder = orderRepository.save(order)
        
        // Restore product stock
        product.stockQuantity = product.stockQuantity!! + 1
        productRepository.save(product)
        
        return mapToOrderResponse(savedOrder)
    }
    
    private fun generateOrderNumber(): String {
        val timestamp = System.currentTimeMillis()
        val random = Random().nextInt(1000)
        return "ORD-${timestamp}-${random.toString().padStart(3, '0')}"
    }
    
    private fun mapToOrderResponse(order: Order): OrderResponse {
        return OrderResponse(
            id = order.id!!,
            orderNumber = order.orderNumber!!,
            totalAmount = order.totalAmount!!,
            status = order.status,
            createdAt = order.createdAt!!.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME),
            user = UserSummary(
                id = order.user?.id!!,
                name = order.user?.name!!,
                email = order.user?.email!!
            ),
            products = order.products?.map { product ->
                ProductSummary(
                    id = product.id!!,
                    name = product.name!!,
                    price = product.price!!
                )
            } ?: emptyList()
        )
    }
}